---
type: 正则表达
tags:
  - 教程
  - 程序
time: 2025-02-17
source:
  - https://www.runoob.com/regexp/regexp-intro.html
  - https://regexone.com/
description:
---
# 介绍

# 语法
## 正则表达式元字符和特性
### 字符匹配
- 普通字符：普通字符按照字面意义进行匹配，例如匹配字母 "a" 将匹配到文本中的 "a" 字符。
- 元字符：元字符具有特殊的含义，例如 `\d` 匹配任意数字字符，`\w` 匹配任意字母数字字符，`.` 匹配任意字符（除了换行符）等。
### 量词
- `*`：匹配前面的模式零次或多次。
- `+`：匹配前面的模式一次或多次。
- `?`：匹配前面的模式零次或一次。
- `{n}`：匹配前面的模式恰好 n 次。
- `{n,}`：匹配前面的模式至少 n 次。
- `{n,m}`：匹配前面的模式至少 n 次且不超过 m 次。
### 字符类
- `[ ]`：匹配括号内的任意一个字符。例如，`[abc]` 匹配字符 "a"、"b" 或 "c"。
- `[^ ]`：匹配除了括号内的字符以外的任意一个字符。例如，`[^abc]` 匹配除了字符 "a"、"b" 或 "c" 以外的任意字符。
### 边界匹配
- `^`：匹配字符串的开头。
- `$`：匹配字符串的结尾。
- `\b`：匹配单词边界。
- `\B`：匹配非单词边界。
\b 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面：`/ter\b/`
下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：`/\Bapt/`
字符串 apt 出现在单词 Chapter 中的非单词边界处，但出现在单词 aptitude 中的单词边界处。对于 \B 非单词边界运算符，不可以匹配单词的开头或结尾，如果是下面的表达式，就不匹配 Chapter 中的 Cha：`\BCha`
### 分组和捕获
- `( )`：用于分组和捕获子表达式。
- `(?: )`：用于分组但不捕获子表达式。
### 特殊字符
- `\`：转义字符，用于匹配特殊字符本身。将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("它具有最高的优先级。示例：\d、\. 等，其中 \d 匹配数字，\. 匹配点号。
- `.`：匹配任意字符（除了换行符）。
- `|`：用于指定多个模式的选择
### 限定符
- `{n}`：n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 "Bob" 中的 o，但是能匹配 "food" 中的两个 o。
- `{n,}`：n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 "Bob" 中的 o，但能匹配 "foooood" 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o*。
- `{n,m}`：m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 "fooooood" 中的前三个 o。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。
### 修饰符（标记）
标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。
标记不写在正则表达式里，标记位于表达式之外，格式如下
`/pattern/flags`
- `i`:ignore - 不区分大小写-将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。
- `g`:global - 全局匹配-查找所有的匹配项。
- `m`:multi line - 多行匹配-使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。
- `s`:特殊字符圆点`.`中包含换行符`\n`-默认情况下的圆点`.`是匹配除换行符`\n`之外的任何字符，加上`s`修饰符之后,`.`中包含换行符`\n`。
### 非打印字符
非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：
- `\cx`:匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
- `\f`	:匹配一个换页符。等价于 \x0c 和 \cL。
- `\n`	:匹配一个换行符。等价于 \x0a 和 \cJ。
- `\r`	:匹配一个回车符。等价于 \x0d 和 \cM。
- `\s`	:匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。
- `\S`	:匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
- `\t`	:匹配一个制表符。等价于 \x09 和 \cI。
- `\v` :匹配一个垂直制表符。等价于 \x0b 和 \cK。

- `(pattern)`:匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。
- `(?:pattern)`:匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。
- `(?=pattern)`:正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，"Windows(?=95|98|NT|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始
- `(?!pattern)`:正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如"Windows(?!95|98|NT|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
- `(?<=pattern)`:反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，"(?<=95|98|NT|2000)Windows"能匹配"2000Windows"中的"Windows"，但不能匹配"3.1Windows"中的"Windows"。
- `(?<!pattern)`:反向否定预查，与正向否定预查类似，只是方向相反。例如"(?<!95|98|NT|2000)Windows"能匹配"3.1Windows"中的"Windows"，但不能配"2000Windows"中的"Windows"。
# 例子
- `[ABC]` ：匹配 [...] 中的所有字符，例如 [aeiou] 匹配字符串 "google runoob taobao" 中所有的 e o u a 字母。
- `[^ABC]` ：匹配除了 [...] 中字符的所有字符，例如 [^aeiou] 匹配字符串 "google runoob taobao" 中除了 e o u a 字母的所有字符。
- `[A-Z]` 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。
- `.` :匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]
- `[\s\S]` :匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。
- `\w` :匹配字母、数字、下划线。等价于 [A-Za-z0-9_]
- `\d` :匹配任意一个阿拉伯数字（0 到 9）。等价于 [0-9]
- `$` : 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r'。要匹配 $ 字符本身，请使用 \\$。 
- `( )` : 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)。 
- `*`: 匹配前面的子表达式零次或多次。要匹配 \* 字符，请使用 \\\*。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于 {0,}。
 - `+` : 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。例如，zo+ 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 `* 和 + 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。`
 - `.` : 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。 
 - `[` : 标记一个中括号表达式的开始。要匹配 \[，请使用 \\\[。 
 - `?` : 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。 例如，do(es)? 可以匹配 "do" 、 "does"、 "doxy" 中的 "do" 和 "does"。? 等价于 {0,1}。
 - `\` : 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\\n' 匹配换行符。序列 '\\\\' 匹配 "\\"，而 '\\(' 则匹配 "("。 
 - `^` : 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \\^。
 - `{` : 标记限定符表达式的开始。要匹配 {，请使用 \\{。 
 - `|` : 指明两项之间的一个选择。要匹配 \|，请使用 \\\|。 
 - `exp1(?=exp2)`：查找 exp2 前面的 exp1。
 - `(?<=exp2)exp1`：查找 exp2 后面的 exp1。
 - `exp1(?!exp2)`：查找后面不是 exp2 的 exp1。
 - `(?<!exp2)exp1`：查找前面不是 exp2 的 exp1。
### 反向引用
```
var str = "Is is the cost of of gasoline going up up";
var patt1 = /\b([a-z]+) \1\b/igm;
document.write(str.match(patt1));
```
捕获的表达式，正如 [a-z]+ 指定的，包括一个或多个字母。正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。`\1` 指定第一个子匹配项。
单词边界元字符确保只检测整个单词。否则，诸如 "is issued" 或 "this is" 之类的词组将不能正确地被此表达式识别。
正则表达式后面的全局标记 `g` 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。
表达式的结尾处的不区分大小写 `i` 标记指定不区分大小写。
多行标记 `m` 指定换行符的两边可能出现潜在的匹配。
```
var str = "https://www.runoob.com:80/html/html-tutorial.html";
var patt1 = /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/;
arr = str.match(patt1);
for (var i = 0; i < arr.length ; i++) {
    document.write(arr[i]);
    document.write("<br>");
}
```
第三行代码 str.match(patt1) 返回一个数组，实例中的数组包含 5 个元素，索引 0 对应的是整个字符串，索引 1 对应第一个匹配符（括号内），以此类推。
第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。
第二个括号子表达式捕获地址的域地址部分。子表达式匹配非 : 和 / 之后的一个或多个字符。
第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。
最后，第四个括号子表达式捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。
将正则表达式应用到上面的 URI，各子匹配项包含下面的内容：
第一个括号子表达式包含 https
第二个括号子表达式包含 www.runoob.com
第三个括号子表达式包含 :80
第四个括号子表达式包含 /html/html-tutorial.html
